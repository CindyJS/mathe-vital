---
title: $\mathbb{C}$ (für Experten)
layout: page
category: LinAlg1
---

        <h1>Mehrfachüberlagerungen der komplexen Zahlenebene
</h1>
<div  style=" line-height: 1.5">
Das folgende Applet ist der Versuch einer Visualisierung eines fortgeschrittenen Konzepts der komplexen
Funktionentheorie: <i>Mehrfachüberlagerungen</i>.

Wir haben in den vorherigen Applets gesehen, dass man zur Definition der $k$-ten Wurzelfunktion
<ul>
<li>    entweder $k$ verschiedene Funktionen $\mathbb{C}\to\mathbb{C}$ definieren kann, die sich dann aber unstetig verhalten,
<li>oder Stetigkeit dadurch erhalten kann, dass man die Wurzelzweige "mitverfolgt"; dann liegen allerdings keine Funktionen mehr vor.
</ul>

<table align ="left"><tr><td width="200"><img src="Wendel3.png" alt="Wendel.png" width='168' height='360' border ="1" /></td></tr></table>
Es gibt allerdings noch einen dritten Ausweg, mit dem man sowohl Stetigkeit als auch  den Funktionenbegriff beim Berechnen
der $k$-ten Wurzeln retten kann. Wir haben gesehen, dass es keine stetige Wurzelfunktionen
$\mathbb{C}\to\mathbb{C}$ geben kann. Man kann dieses Dilemma dadurch umgehen, dass man den Definitionsbereich modifiziert.
Beschränken wir uns zur Erklärung wieder auf den Fall der dritten Wurzeln $\sqrt[3]{\cdots}$.
Die Grundidee besteht darin, dass man den Definitionsbereich $\mathbb{C}$ durch drei Kopien seiner selbst ersetzt
und diese auf geschickte Weise miteinander verklebt. Es soll erreicht werden, dass man - wenn der Urbildpunkt $z$ mehrfach
um den Ursprung läuft - zyklisch alle drei Kopien von $\mathbb{C}$ durchläuft. Man schraubt sich- vergleichbar mit einer Wendeltreppe -
von der ersten Kopie in die zweite und von dort beim nächsten Umlauf in die dritte Kopie. Der nächste Umlauf befördert einen
(vollkommen "unwendeltreppenmäßig") wieder zurück in die erste Kopie.
<br> <br>
Um dies zu erreichen,
entfernt man zunächst den Nullpunkt aus der komplexen Ebene $\mathbb{C}$. Sodann erstellt man drei Kopien
des Bereiches $\mathbb{C}-\{0\}$. Diese schlitzt man entlang der positiven reellen Halbachse auf (die Lage dieses Schnittes ist in gewisser Weise willkürlich;
sie muss nur in allen drei Kopein an der gleichen Stelle sein). Bezeichnen wir die drei Kopien mit
$\mathbb{C}_1$,
$\mathbb{C}_2$ und
$\mathbb{C}_3$.
Diese drei Ebenen werden nun entlang der Schlitze verklebt.
Wir nehmen den Bereich von $\mathbb{C}_1$, der unterhalb des Schlitzes liegt, und verkleben ihn passgenau mit dem Teil von
$\mathbb{C}_2$, der oberhalb des Schlitzes liegt. Ebenso verkleben wir nun den Teil von $\mathbb{C}_2$, der unterhalb des Schlitzes
liegt, mit dem Teil von $\mathbb{C}_3$, der oberhalb des Schlitzes liegt.
Startet man bei den so verklebten Ebenen wenig oberhalb der $1$ von $\mathbb{C}_1$ und rotiert um den Nullpunkt, so gelangt man - wenn man nach
circa einer Umdrehung die positive Hälfte der reellen Achse wieder überquert -
in der Kopie $\mathbb{C}_2$\mathbb{C}. Nach einer weiteren Umdrehung landet man in $\mathbb{C}_3$.
<br> <br>
Last but not least verkleben wir noch den Bereich unter dem Schlitz von $\mathbb{C}_3$ mit dem Bereich über dem Schlitz von $\mathbb{C}_1$.
So bringt uns eine weitere Drehung zurück in die Ebene $\mathbb{C}_1$. (Will man diese Verklebungen wirklich geometrisch realisieren, so geht das natürlich nicht ohne
Selbstdurchdringung). Tatsächlich lässt sich nach dieser Prozedur der Nullpunkt wieder in die ganze verklebte Konstruktion einfügen, und dies sogar so, das topologisch keine
"Singularität" entsteht.
<br> <br>
Das so entstandene Gebilde (nennen wir es $\mathbb{C}_{\sqrt[3]{\cdots}}$) ist nun der ideale Definitionsbereich für die Funktion $\sqrt[3]{\cdots}$.
Auf diesem Gebilde kann man nun tatsächlich die drei Äste der dritten Wurzelfunktion
als echte Funktionen $f\colon \mathbb{C}_{\sqrt[3]{\cdots}}\to\mathbb{C}$ definieren. Es ist einfach genügend Platz vorhanden, um eine Eindeutigkeit zu gewährleisten.
<br> <br>
Das folgende Applet veranschaulicht nun den Wechsel zwischen den einzelnen Ebenen dadurch, dass die Hintergrundfarbe entsprechend der Ebene
verändert wird. Bildlich gesprochen gibt die Hintergrundfarbe an, auf welchem "Stockwerk" wir uns gerade befinden.
Man kann leicht erkennen, dass  - wenn man als Koordinaten von $z$ die Position in der ursprünglichen $\mathbb{C}$-Ebene und zusätzlich die
Farbe des Hintergrundes nimmt - sich die Positionen der Wurzeln als Funktion auffassen lassen.
 <br> <br> <br>
</div>

        <script id='init' type='cindyscript'>
        drawarrow(a,b,col,alp):=(
        regional(n);
           n=b-a;
           n=n*0.5;
           p=(n_2,-n_1);
           draw(a,b,color->col,size->2,alpha->alp);
           draw(b-n*.17+p*.07,b,color->col,size->2,alpha->alp);
           draw(b-n*.17-p*.07,b,color->col,size->2,alpha->alp);

        );
        drawl(a,b,col,alp):=(
           draw(a,b,color->col,size->2,alpha->alp);

        );

kold=0;
cont=false;
snap=false;
oldfirst=0.1;
        </script>

        <script id='firstDrawing' type='cindyscript'>
           if(snap,
          javascript("document.getElementById('swsnap').classList.add('selected')");
          javascript("document.getElementById('swsnap').classList.remove('unselected')");
        );
        if(!snap,
          javascript("document.getElementById('swsnap').classList.add('unselected')");
          javascript("document.getElementById('swsnap').classList.remove('selected')");
        );
        if(cont,
          javascript("document.getElementById('swtrace').classList.add('selected')");
          javascript("document.getElementById('swtrace').classList.remove('unselected')");
        );
        if(!cont,
          javascript("document.getElementById('swtrace').classList.add('unselected')");
          javascript("document.getElementById('swtrace').classList.remove('selected')");
        );

          x=S.x;
          if(x<S1.x,x=S1.x);
          if(x>S2.x,x=S2.x);

          S.xy=(x,S1.y);

        n=round(10*(|S,S1|/|S1,S2|))+2;


        drawtext((.5,1.7),"k="+(n));
        off=(.1,-.5);
        draw(line((0,1,0)),color->(0,0,0),size->0.5);
        draw(line((1,0,0)),color->(0,0,0),size->0.5);
        if(snap,B.xy=B/|B|;);
        drawarrow(O,B,(0.7,0,0),1);
        z=complex(B.xy);
        ew=exp(i*2*pi/n);
        zw=z^(1/n);
        pol=apply(0..(n-1),(zw*ew^#));
        zw=sort(pol,|oldfirst,#|)_1;
        pol=apply(0..(n-1),(zw*ew^#));
        oldfirst=pol_1;
        pol=apply(pol,gauss(#));


col=floor(-arctan2(gauss(oldfirst)_1,gauss(oldfirst)_2)/(2*pi)*n+1)/n;
if(cont,
col=-arctan2(gauss(oldfirst)_1,gauss(oldfirst)_2)/(2*pi);
);
fillcircle((0,0),100,color->(hue(col)),alpha->0.2);

        nn=gauss(z)/|gauss(z)|;
        drawtext(gauss(z)+nn*.15+(-0.03,-0.04),"z",size->20,alpha->alpha^2);
fillpoly(pol,alpha->0.3);
drawpoly(pol,color->(0,0,0));
ii=0;
 drawcircle((0,0),1);

forall(pol,draw(#,color->hue(ii/n),size->5);ii=ii+1);


        </script>



        <div style="position:relative">
        <canvas  id="CSCanvas" width=800 height=500  style="border:2px solid #000000; top:0px; left:0px;"></canvas>
            <button  id="swsnap" onclick="cdy.evokeCS('snap=!snap;')" type="button" style=" top:450px;left:20px; height:30px" >einrasten</button>
            <button  id="swtrace" onclick="cdy.evokeCS('cont=!cont;')" type="button" style=" top:450px;left:120px; height:30px" >kontinuierlich</button>

</div>

        <script type="text/javascript">

            var gslp=[
                      {name:"O", type:"Free", pos:[0,0],color:[0,0,0],pinned:true,size:3},
                      {name:"B", type:"Free", pos:[2,.7],color:[1,1,1],size:4},
                      {name:"C", type:"Free", pos:[-3,3],color:[1,0,0],size:0.01},
                      {name:"S1", type:"Free", pos:[0.5,2],color:[0,0,0],pinned:true,size:2},
    {name:"S2", type:"Free", pos:[2,2],color:[0,0,0],pinned:true,size:2},
    {name:"S", type:"Free", pos:[.7,2],color:[1,0.5,0.5],pinned:false,size:4},
    {name:"l", type:"Segment", args:["S1","S2"],color:[0,0,0],pinned:false,size:2},




                    ];
                     cdy=createCindy({canvasname:"CSCanvas",
                        movescript:"firstDrawing",
                        initscript:"init",
                        geometry:gslp,
                        grid:.5,
                        snap:false,
                        ports:[{
                        id:"CSCanvas",
                        transform:[{visibleRect:[-3,3,3,-3]},],
                        virtualwidth: 600,
                        virtualheight: 450,
                        }],
}
                        );

        </script>

  <!--      END ADD-->

<div  style=" line-height: 1.5">
<br>
<br>
Wie bereits erwähnt, ist die Wahl der Position des Schnittes durch die Ebenen eigentlich willkürlich. Es ist viel angemessener, von einem
kontinuierlichen Übergang auszugehen. Drückt man oben den Schalter "kontinuierlich" wird die Hintergrundfarbe kontinuierlich angepasst. Die besondere Rolle des Übergangs durch die positive reelle
Halbachse entfällt somit komplett. Bildlich gesprochen, befinden wir uns nun eher auf der Wendeltreppe als in den Stockwerken.
Die Farbe gibt an, auf welcher Höhe der Wendeltreppe wir uns befinden.

<br>
<br>
Wir haben gesehen, dass eine Wurzelfunktion praktisch den ihr am besten angepassten Definitionsbereich
selbst mitbringt. Tatsächlich ist dies bei allen (sinnvollen) komplexen Funktionen ebenso der Fall.
Die Lage der Stockwerke und der Wendeltreppen kann nur um einiges komplexer werden.
Man spricht von der einer Funktion $f$ zugeordneten <b>Riemann'schen Fläche</b>.
</div>

</div>
